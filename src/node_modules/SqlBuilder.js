"use strict";
/* -------------------------------------------------------------------
 * Require Statements << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

var PongUtils = require('PongUtils');
var Sql = require('Sql');

/* =============================================================================
 * 
 * SqlBuilder - PARTIAL port of https://github.com/StackExchange/dapper-dot-net/tree/master/Dapper.SqlBuilder
 * 
 * SPECIFICALLY FOR POSTGRES
 * 
 * NO SUPPORT FOR:
 * inclusive OR, e.g. "where (a = b OR c = d)"
 * initial template parameters (i've never needed them)
 * most clauses
 * ========================================================================== */

module.exports = SqlBuilder;

/**
 * There are two usage scenarios for SqlBuilder: 
 * 1) single query template that won't have different select result columns (most common)
 * 2) multiple query templates that share where clauses and will all be executed, 
 * e.g. for paging: "select count(*)" and "select *"
 * 	
 * @param sql {String} when provided, assumes single query template - you don't need to call {@link SqlBuilder.newTemplate}
 * @param params {Object} when provided, adds initial params for any named @parameters in the provided sql
 * @constructor
 */
function SqlBuilder(sql, params)
{
	this.name_clauses = { };
	this.clauseCount = 0;

	/**
	 * When initial sql is provided in SqlBuilder's constructor, this will be instantiated and used for querying
	 * @type {Template}
	 * @private
	 */
	this._singleTemplate = null;
	
	if (sql)
	{
		this._singleTemplate = this.newTemplate(sql, params);
	}
}

/* -------------------------------------------------------------------
 * SqlBuilder - Static Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/* -------------------------------------------------------------------
 * SqlBuilder - Getters / Setters
 * ---------------------------------------------------------------- */

/* -------------------------------------------------------------------
 * SqlBuilder - Prototype Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * adds a clause to the --[SqlBuilder: limit] placeholder in the template's sql
 * 
 * @param sql {String} e.g. 'limit 50', 'limit @maxGames'
 * @param params {Object} e.g. { maxGames: 50 }
 */
SqlBuilder.prototype.limit = function(sql, params)
{
	addClause({ name: 'limit', prefix: 'limit ' }, this, sql, params); 
};

/**
 * returns a new {Template} for this {SqlBuilder} with the parameter sql as its building block
 * @param sql {String} e.g. 'select * from table --[SqlBuilder: where]'
 * @param params {Object} initial named @parameters found in the sql
 * @return {Template}
 */
SqlBuilder.prototype.newTemplate = function(sql, params)
{
	return new Template(this, sql, params);
};

/**
 * adds a clause to the --[SqlBuilder: order by] placeholder in the template's sql
 * 
 * @param sql {String} e.g. 'a.id desc'
 */
SqlBuilder.prototype.orderBy = function(sql)
{
	addClause({ name: 'order by', joiner: ', ', prefix: 'order by ' }, this, sql);
};

/**
 * returns a DB query result from the initial sql provided in this SqlBuilder's 
 * constructor - i.e. the "single template" case discussed in the constructor's docs.
 * 
 * Throws an error if no sql was provided during construction. 
 */
SqlBuilder.prototype.query = function*()
{
	if (this._singleTemplate == null) throw new Error("no sql was provided during this SqlBuilder's construction");
	
	return yield this._singleTemplate.query();
};

/**
 * adds a clause to the --[SqlBuilder: where] placeholder in the template's sql
 * 
 * @param sql {String} e.g. 'a.id = @id'
 * @param params {Object} e.g. { id: 5 }
 */
SqlBuilder.prototype.where = function(sql, params)
{
	addClause({ name: 'where', joiner: ' and ', prefix: 'where ' }, this, sql, params);
};

/* -------------------------------------------------------------------
 * SqlBuilder - Private Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

function addClause(options, builder, sql, params)
{
	var defaults =
	{
		name: null,
		joiner: '',
		prefix: '',
		postfix: '\n'
	};
	var settings = PongUtils.extend({}, defaults, options),
		clauses = builder.name_clauses[settings.name];
	
	if (!clauses)
	{
		clauses = new Clauses(settings.joiner, settings.prefix, settings.postfix);
		builder.name_clauses[settings.name] = clauses;
	}
	
	clauses.array.push(new Clause(sql, params));
	builder.clauseCount++;
}

/**
 * One or more sql statements associated with a {SqlBuilder}.
 * 
 * For example, a builder could have one sql query for selecting counts and another for selecting full records.
 * In this case, there would be two templates created, and the same paramters added to the builder would apply to
 * both templates.
 * 
 * @param builder {SqlBuilder} the builder to add clauses and parameters to
 * @param sql {String} the specific sql query (or variant)
 * @param params {Object} initial named @parameters found in the sql
 * @constructor
 */
function Template (builder, sql, params)
{
	this.builder = builder;
	this.initSql = sql;
	this.initParams = params;
	this.resolvedClauseCount = -1; // when this doesn't match builder.clauseCount, we'll resolve
	
	this.resolvedSql = '';
	this.resolvedParams = [];
}

/* -------------------------------------------------------------------
 * Template - Static Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/* -------------------------------------------------------------------
 * Template - Getters / Setters
 * ---------------------------------------------------------------- */
Object.defineProperties(Template.prototype,
{
	/**
	 * ready-to-run sql with ordinal parameters
	 */
	sql: {
		get: function () { resolveSql(this); return this.resolvedSql; }
	},
	/**
	 * ordinal parameter array for {Template} sql
	 */
	params: {
		get: function() { resolveSql(this); return this.resolvedParams; }
	}
});

/* -------------------------------------------------------------------
 * Template - Prototype Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * returns a database query result for the execution of {Template} sql and params 
 */
Template.prototype.query = function*()
{
	return yield Sql.using(function*(db)
	{
		return yield db.query(this.sql, this.params);
	}.bind(this));
};

/* -------------------------------------------------------------------
 * Template - Private Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * prepares sql for execution 
 * @param t {Template}
 */
function resolveSql(t)
{
	if (t.resolvedClauseCount === t.builder.clauseCount) return;
	
	t.resolvedSql = t.initSql;
	t.resolvedParams = [];
	
	var clauseParams = PongUtils.extend({}, t.initParams);

	for (var name in t.builder.name_clauses)
	{
		var clauses = t.builder.name_clauses[name],
			clauseSql = clauses.resolveSql(clauseParams), // also pushes params into clauseParams
			r = new RegExp('--\\[SqlBuilder:\\s?' + name + '\\]', 'i');
		
		t.resolvedSql = t.resolvedSql.replace(r, clauseSql);
	}
	
	// replace any @param with $ordinal in the sql
	var paramNames = t.resolvedSql.match(/@\w+/ig) || [];
		
	paramNames.forEach(function(name, i)
	{
		t.resolvedSql = t.resolvedSql.replace(name, '$' + (i + 1));
		t.resolvedParams.push(clauseParams[name.substr(1)]);
	});
	
	t.resolvedClauseCount = t.builder.clauseCount;
}


/* -------------------------------------------------------------------
 * Private Classes
 * ---------------------------------------------------------------- */

function Clause(sql, params)
{
	this.sql = sql;
	this.params = params;
}

function Clauses(joiner, prefix, postfix)
{
	this.array = [];
	
	this.joiner = joiner;
	this.prefix = prefix;
	this.postfix = postfix;
}

Clauses.prototype.resolveSql = function(templateParams)
{
	var sqlArray = [];
	
	this.array.forEach(function(c)
	{
		PongUtils.extend(templateParams, c.params);
		sqlArray.push(c.sql);
	});
	
	return this.prefix + sqlArray.join(this.joiner) + this.postfix;
};