"use strict";

(function (exports) {
    var Sql = require('Sql');
    var glicko2 = require('glicko2');

    function _defaultRatings(allPlayers) {
        var ranking = new glicko2.Glicko2({
            tau:    0.5,
            rating: 1500,
            rd:     200,
            vol:    0.06
        });

        var playerLookup = [];

        for(var i = 0; i < allPlayers.rowCount; i++) {
            var player = allPlayers.rows[i];

            // everyone starts default, we're not going to figure out
            // starting rankings
            var glickoPlayer = ranking.makePlayer();
            playerLookup[player.id] = glickoPlayer;
            if(!glickoPlayer.name) { 
                glickoPlayer.name = player.name;
            }
        }

        return { ranking: ranking, playerLookup: playerLookup };
    }

    // Updates Ratings for all players
    // It's not sensical, for most ranking systems anyway, to update the score
    //   after every match.  So we have to take an intervalDays to say when to recalculate.
    // By default, I think a week makes sense; but I'm not going to make that decision in this
    //   code.  Let whatever actually calls into it decide what's appropriate.
    function * updateRatings(intervalDays) {
        var intervalMilliseconds = intervalDays * 24 * 60 * 60 * 1000;

        yield Sql.using(
            function * (db) {
                var allGames = yield db.query(
                                    'SELECT G.played_date, G.game_type_id, GP.* '+
                                    'FROM games G '+
                                    'JOIN games_players GP ON G.id = GP.game_id '+
                                    'WHERE G.game_type_id IN (1,3)   -- singles only '+
                                    'ORDER BY G.played_date, G.id'
                                ); 

                // nothing to do
                if(allGames.rowCount == 0) {
                    console.log('nothing to do');
                    return;
                }

                var allPlayers = yield db.query('SELECT * FROM players');

                var tuple = _defaultRatings(allPlayers);
                var ranking = tuple.ranking;
                var playerLookup = tuple.playerLookup;
                var hasPlayedAGame = [];

                var lastRecalc = allGames.rows[0].played_date;
                var pendingMatches = [];
                var processPendingMatches = function(date) {
                        if(pendingMatches.length > 0) {
                            ranking.updateRatings(pendingMatches);
                        }

                        for(let i = 0; i < pendingMatches.length; i++) {
                            var p1 = pendingMatches[i][0];
                            var p2 = pendingMatches[i][1];
                            var p1Ix = playerLookup.indexOf(p1);
                            var p2Ix = playerLookup.indexOf(p2);

                            hasPlayedAGame[p1Ix] = true;
                            hasPlayedAGame[p2Ix] = true;
                        }

                        lastRecalc = date;
                        pendingMatches = [];
                };

                for(let i = 0; i < allGames.rowCount; i+=2) {
                    var gp1 = allGames.rows[i];
                    var gp2 = allGames.rows[i+1];

                    if(gp1.game_id != gp2.game_id) throw ("Game ids don't match, which shouldn't be possible; "+gp1.game_id+" vs "+gp2.game_id);

                    var needUpdate = (gp1.played_date - lastRecalc) >= intervalMilliseconds;
                    if(needUpdate) {
                        processPendingMatches(gp1.played_date);
                    }

                    var p1 = playerLookup[gp1.player_id];
                    var p2 = playerLookup[gp2.player_id];

                    var winner = gp1.score > gp2.score ? p1 : p2;
                    var loser = gp1.score > gp2.score ? p2 : p1;
                    var wonBy = Math.max(gp1.score, gp2.score) - Math.min(gp1.score, gp2.score);
                    var outOf = gp1.game_type_id == 1 ? 11 : 21;

                    var relativeWin;
                    if(loser == 0) {
                        // a skunk is a straight win
                        relativeWin = 1;
                    } else {
                        // winning by exactly 2 points is a 0.55;
                        //   we smear (linearly) back up to 1 for winning by 
                        //   19 (or 9)
                        relativeWin = 0.55 + (wonBy / (outOf - 2)) * 0.45;
                    }

                    pendingMatches.push([winner, loser, relativeWin]);
                }

                // ignore the last games, *unless* right now is later (ie. if now games have been played
                //   since a recalc should have happened, but enough has passed to force the issue)
                var now = Date.now();
                if(now - lastRecalc >= intervalMilliseconds) {
                    processPendingMatches(now);
                }

                for(let i = 0; i < playerLookup.length; i++) {
                    var player = playerLookup[i];
                    var hasPlayed = hasPlayedAGame[i];
                    // only update if they've played a game
                    if(player && hasPlayed) {
                        var rating = player.getRating();
                        yield db.query('UPDATE players SET rating = $1 WHERE id = $2', [rating, i]);
                    }
                }
            }
        );
    }

    function * getOverallRatings() {
        var Sql = require('Sql');
        var ret = [];
        yield Sql.using(
            function * (db) {
                var allPlayers = yield db.query(
                                    'SELECT * FROM players WHERE rating <> 0 ORDER BY rating DESC LIMIT 100'
                                ); 

                for(var i = 0; i < allPlayers.rowCount; i++) {
                    var row = allPlayers.rows[i];
                    ret.push({ player_id: row.id, player_name: row.name, player_rating: row.rating });
                }
            }
        );


        return ret;
    }

    exports.updateRatings = updateRatings;
    exports.getOverallRatings = getOverallRatings;
})(module.exports);