"use strict";

var Game = require('models/Game');
var Player = require('models/Player');
var PongUtils = require('PongUtils');
var Sql = require('Sql');
var SqlBuilder = require('SqlBuilder');

module.exports = Match;

/**
 * Represents a group of contiguously-played games by the same players.
 * 
 * Currently, this acts like a sequence, only providing an identifier to put on the games table.
 * 
 * @constructor
 */
function Match()
{
	// columns
	this.id = 0;

	/**
	 * Memoized {Game} objects, usually instantiated after a call to {@link Match.addGame} or {@link Match.getAllGames}
	 * @type {Array}
	 * @private
	 */
	this._games = [];
}

/* -------------------------------------------------------------------
 * Getters / Setters
 * ---------------------------------------------------------------- */

 Object.defineProperties(Match.prototype,
{
});

/* -------------------------------------------------------------------
 * Prototype Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

Match.prototype.addGame = function*(game)
{
	yield validateBeforeAdd(this, game);
	
	yield Sql.using(function*(db)
	{
		yield db.query('update games set match_id = $1 where id = $2;', [this.id, game.id]);
		game.match_id = this.id;
	}.bind(this));
	
	this._games.push(game);
};

Match.prototype.getAllGames = function*()
{
	var gameCount = yield this.getGameCount();

	if (this._games.length !== gameCount)
	{
		this._games = yield Game.getAllByMatchId(this.id);
	}

	return this._games;
};

Match.prototype.getGameCount = function*()
{
	var sql = Sql.fromComment(function ()
	{/*!
	
select 
	count(*) as game_count
from 
	matches m 
	inner join games g on g.match_id = m.id 
where
	m.id = @id

*/
	});
	
	var b = new SqlBuilder(sql, { id: this.id }),
		q = yield b.query();
	
	return parseInt(q.rows[0].game_count);
};

/**
 * returns winning team array or null if match isn't complete
 * @return {Array|null} winning team {Player} array or null if no winning team
 */
Match.prototype.getWinningTeam = function*()
{
	var games = yield this.getAllGames();

	if (games.length === 1) return null;

	var t1 = games[0].team1,
		t2 = games[0].team2;

	var t1Wins = games.filter(function (game) { return Game.isSameTeam(t1, game.team1) }).length,
		t2Wins = games.filter(function (game) { return Game.isSameTeam(t2, game.team1) }).length;

	return t1Wins === t2Wins ? null : t1Wins > t2Wins ? t1 : t2;
};

/**
 * returns true if this match consists of an odd number of games
 * @return {boolean}
 */
Match.prototype.isComplete = function*()
{
	var winningTeam = yield this.getWinningTeam();
	return winningTeam != null; 
};


/* -------------------------------------------------------------------
 * Static Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * Returns a newly persisted {Match} whose id can be set on a {Game}'s matchId.
 */
Match.newMatch = function*()
{
	var m = new Match();
	
	yield Sql.using(function*(db)
	{
		var query = yield db.query('insert into matches values(default) returning id;');
		m.id = query.rows[0].id;
	});
	
	return m;
};

/* -------------------------------------------------------------------
 * Private Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * throws an Error if newGame cannot be added to match
 * @param match {Match}
 * @param newGame {Game}
 */
function* validateBeforeAdd(match, newGame)
{
	if (!newGame.id) {
		throw new Error('may only add saved games');
	}
	// var games = yield match.getAllGames();

	// // no existing games, so we're good to add
	// if (!games.length) return;
	
	// if (games[0].game_type_id !== newGame.game_type_id){
	// 	throw new Error('may only add the same type of game to an existing match');
	// }
	// if (!Game.hasSameTeams(games[0], newGame)){
	// 	throw new Error('only the same teams may play in the same match');
	// }
;
}