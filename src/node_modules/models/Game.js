"use strict";

var Player = require('models/Player');
var Sql = require('Sql');
var PongUtils = require('PongUtils');

/* =============================================================================
 * 
 * Game
 *  
 * ========================================================================== */

module.exports = Game;

/**
 * A singles or doubles game, by default played to 11 (win by 2).
 * @constructor
 */
function Game()
{
	this.id = 0;
	
	this.played_date = new Date();
	this.game_type_id = Game.types.singles;

	this.team1 = [];
	this.team1Score = 0;

	this.team2 = [];
	this.team2Score = 0;

	this.recorded_by_player_id = 0;
}

Game.types =
{
	singles: 1,
	doubles: 2
};

/* -------------------------------------------------------------------
 * Getters / Setters
 * ---------------------------------------------------------------- */
Object.defineProperties(Game.prototype,
{
	isSaved: 
	{
		get: function () { return this.id > 0; }
	},
	
	isDoublesGame: 
	{
		get: function() { return this.game_type_id === Game.types.doubles; }
	},
	
	isSinglesGame: 
	{
		get: function() { return this.game_type_id === Game.types.singles; }
	}
	
});


/* -------------------------------------------------------------------
 * Static Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * @return {Game} with game and player information for the parameter game 'id'
 */
Game.getById = function*(id)
{
	var game = null;
	if (typeof id != 'number' || id <= 0) return game;
	
	yield Sql.using(function*(db) 
	{
		var sp = getSqlAndParams({ gameId: id }),
			query = yield db.query(sp.sql, sp.params);
		
		if (query.rowCount > 0)
		{
			game = parseGameFromQuery(query.rows);
		}
	});
	
	return game;
};

Game.getAllGamesForPlayer = function*(player_id)
{ 
	var game_ids = [];
	var games = [];

	if (typeof player_id != 'number' || player_id <= 0) return game_ids;

	yield Sql.using(function*(db) 
	{
		var dbResult = yield db.query("select game_id from games_players where player_id = $1;", [player_id]);

		for (var i=0; i<dbResult.rowCount; i++){
			game_ids.push(dbResult.rows[i].game_id);
		}
	});

	for (var i=0; i<game_ids.length;i++){
		var game = yield Game.getById(game_ids[i]);
		games.push(game);
	}
	return games;
};

/**
 * By default, returns all games in the database, in no specific order.
 * @param options
 * @return {Game[]}
 */
Game.getMany = function*(options)
{
	var defaults = 
		{ 
			limit: null,
			orderBy: null
		},
		settings = PongUtils.extend({}, defaults, options),
		games = [];

	yield Sql.using(function*(db)
	{
		var sp = getSqlAndParams(settings),
			query = yield db.query(sp.sql, sp.params);

		if (query.rowCount > 0)
		{
			// assumes games are contiguous by id
			games = parseMultipleGamesFromQuery(query.rows, settings.limit);
		}
	});

	return games;
};

/**
 * returns the last 40 games played
 * @return {Game[]}
 */
Game.getRecent = function*(limit)
{
	// note the `g.id desc` - makes it easy for `parseMultipleGamesFromQuery` to iterate
	return yield Game.getMany({ limit: limit || 40,  orderBy: 'g.played_date desc, g.id desc' }); 
};


/* -------------------------------------------------------------------
 * Prototype Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */


/**
 * attempts to persist this Game to the database
 */
Game.prototype.save = function*()
{
	var validationError = validateBeforeSave(this);
	if (validationError)
	{
		throw new Error(validationError);
	}

	this.game_type_id = this.team1.length;

	// team1 always wins
	if (this.team1Score < this.team2Score)
	{
		var swap = this.team2Score;
		this.team2Score = this.team1Score;
		this.team1Score = swap;

		swap = this.team2;
		this.team2 = this.team1;
		this.team1 = swap;
	}

	yield insertGame(this);
};


/* -------------------------------------------------------------------
 * Private Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * Returns an array of games based on a query using {@link getSqlAndParams}
 * @param rows assumes these rows have contiguous game ids
 * @param limit optional max number of Games to parse
 * @return {Game[]}
 */
function parseMultipleGamesFromQuery (rows, limit)
{
	var games = [],
		currentGameId = rows[0].game_id,
		currentRows = [];
	
	// again, these had better have all of a game's rows together
	for (var i = 0; i < rows.length; i++)
	{
		var row = rows[i];
		
		if (row.game_id !== currentGameId)
		{
			games.push(parseGameFromQuery(currentRows));
			currentRows.length = 0;
			currentGameId = row.game_id;
			
			if (limit && games.length >= limit)
			{
				break;
			}
		}
		
		currentRows.push(row);
	}
	
	// and the last one, if we didn't exit early
	if (currentRows.length)
	{
		games.push(parseGameFromQuery(currentRows));
	}
	
	return games;
}

/**
 * Returns a {@link Game} from the sql resulting from {@link getSqlAndParams}
 * @param rows a single game's rows
 * @return {Game}
 */
function parseGameFromQuery (rows)
{
	var g = new Game();
	for (var i = 0; i < rows.length; i++)
	{
		var r = rows[i];
		if (i == 0)
		{
			g.id = r.game_id;
			g.played_date = r.played_date;
			g.game_type_id = rows.length / 2;
		}
		var p = new Player(r);

		// let's make the winner always be team 1
		if (r.is_winner)
		{
			g.team1.push(p);
			g.team1Score = r.score;
		}
		else
		{
			g.team2.push(p);
			g.team2Score = r.score;
		}
	}
	return g;
}

function* insertGame(game)
{
	yield Sql.using(function*(db)
	{
		// first insert the games row, then the games_players
		var dbResult = yield db.query(
			"insert into games (played_date, game_type_id, recorded_by_player_id) values ($1, $2, $3) returning id;",
			[game.played_date, game.game_type_id, game.recorded_by_player_id]);

		game.id = dbResult.rows[0].id;

		if (game.isSaved)
		{
			yield insertGamesPlayers(db, game, 1);
			yield insertGamesPlayers(db, game, 2);
		}
	});
}

function* insertGamesPlayers(db, game, teamNumber)
{
	var teams = game['team' + teamNumber],
		teamScore = game['team' + teamNumber + 'Score'],
		isWinner = teamNumber == 1;
	
	for (var i = 0; i < teams.length; i++)
	{
		yield db.query(
			'insert into games_players (game_id, player_id, is_winner, score) ' +
			'values ($1, $2, $3, $4);', [game.id, teams[i].id, isWinner, teamScore]);
	}
}

function getSqlAndParams(options)
{
	var defaults = 
	{
		gameId: null,
		sort: null,
		limit: null
	};
	var settings = PongUtils.extend({}, defaults, options);
	
	var sql = Sql.fromComment(function ()
	{/*!
	
select 
	g.id as game_id,
	g.played_date,
	p.id as player_id,
	p.name as player_name,
	p.email as player_email,
	p.image_url as player_image_url,
	gp.is_winner,
	gp.score
from 
	games g 
	inner join games_players gp on g.id = gp.game_id 
	inner join players p on p.id = gp.player_id 
--where
--order by
--limit

*/
	});
	var params = [],
		updateSql = function(search, clause, param, isNotParameterizable)
		{
			if (!param) return;
			
			if (isNotParameterizable)
			{
				sql = sql.replace(search, clause + param);
			}
			else
			{
				sql = sql.replace(search, clause + '($' + (params.length + 1) + ')');
				params.push(param);
			}
		};
	
	// if this gets any more convoluted, we'll need to pull in named parameter support
	// or port dapper's sql builder https://github.com/StackExchange/dapper-dot-net/tree/master/Dapper.SqlBuilder
	
	// who knows what's coming back
	if (settings.limit && !settings.orderBy) throw new Error('when limiting, an orderBy must be specified');
	
	updateSql('--limit', 'limit ', settings.limit ? settings.limit * 4 : null); // up to 4 rows/game
	updateSql('--where', 'where g.id = ', settings.gameId);
	updateSql('--order by', 'order by ', settings.orderBy, true);
	
	return { sql: sql, params: params };
}

function validateBeforeSave(game)
{
	if (game.isSaved) 
		return 'already saved (update not supported)';
	
	if (!Array.isArray(game.team1) || !Array.isArray(game.team2))
		return 'teams should be arrays of players';
	
	if (game.team1.length !== game.team2.length)
		return 'teams should have the same number of players';
	
	if (game.team1.length !== Game.types.singles && game.team1.length !== Game.types.doubles)
		return 'only singles and doubles games are supported';
	
	if (game.team1Score < 0 || game.team2Score < 0)
		return 'scores must be positive';
	
	if (game.team1Score === game.team2Score)
		return 'scores cannot be equal';
	
	// TOOD: should we validate that one team won by at least two points?
	
	var team1Ids = game.team1.map(function(p) { return p.id; });
	if (game.team2.some(function(p) { return team1Ids.indexOf(p.id) >= 0; }))
		return 'players cannot be on both teams';
	
	return null;
}