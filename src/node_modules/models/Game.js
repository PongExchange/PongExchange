"use strict";

var Player = require('models/Player');
var PongUtils = require('PongUtils');
var Sql = require('Sql');
var SqlBuilder = require('SqlBuilder');

/* =============================================================================
 * 
 * Game
 *  
 * ========================================================================== */

module.exports = Game;

/**
 * A singles or doubles game, by default played to 11 (win by 2).
 * @constructor
 */
function Game()
{
	this.id = 0;
	
	this.played_date = new Date();
	this.game_type_id = Game.types.singles;

	this.team1 = [];
	this.team1Score = 0;

	this.team2 = [];
	this.team2Score = 0;

	this.recorded_by_player_id = 0;
	
	this.match_id = null;
}

Game.types =
{
	singles: 1,
	doubles: 2
};

/* -------------------------------------------------------------------
 * Getters / Setters
 * ---------------------------------------------------------------- */
Object.defineProperties(Game.prototype,
{
	isSaved: 
	{
		get: function () { return this.id > 0; }
	},
	
	isDoublesGame: 
	{
		get: function() { return this.game_type_id === Game.types.doubles; }
	},
	
	isSinglesGame: 
	{
		get: function() { return this.game_type_id === Game.types.singles; }
	}
	
});


/* -------------------------------------------------------------------
 * Static Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * @return {Game} with game and player information for the parameter game 'id'
 */
Game.getById = function*(id)
{
	var game = null;
	if (typeof id != 'number' || id <= 0) return game;
	
	yield Sql.using(function*(db) 
	{
		var sp = getSqlAndParams({ gameId: id }),
			query = yield db.query(sp.sql, sp.params);
		
		if (query.rowCount > 0)
		{
			game = parseGameFromQuery(query.rows);
		}
	});
	
	return game;
};

Game.getAllByMatchId = function*(matchId)
{
	return yield Game.getMany({ matchId: matchId });
};

Game.getAllGamesForPlayer = function*(player_id)
{ 
	var game_ids = [];
	var games = [];

	if (typeof player_id != 'number' || player_id <= 0) return game_ids;

	yield Sql.using(function*(db) 
	{
		var dbResult = yield db.query("select game_id from games_players where player_id = $1;", [player_id]);

		for (var i=0; i<dbResult.rowCount; i++){
			game_ids.push(dbResult.rows[i].game_id);
		}
	});

	for (var i=0; i<game_ids.length;i++){
		var game = yield Game.getById(game_ids[i]);
		games.push(game);
	}
	return games;
};

/**
 * By default, returns all games in the database, in no specific order.
 * @param options
 * @return {Game[]}
 */
Game.getMany = function*(options)
{
	var defaults = 
		{ 
			gameId: null,
			matchId: null,
			playerId: null,
			limit: null,	// how many games to fetch
			orderBy: null	// how games should be ordered in the result, e.g. 'g.played_date desc' for recent games
		},
		settings = PongUtils.extend({}, defaults, options),
		games = [];

	yield Sql.using(function*(db)
	{
		var sp = getSqlAndParams(settings),
			query = yield db.query(sp.sql, sp.params);
		
		if (query.rowCount > 0)
		{
			// assumes games are contiguous by id
			games = parseMultipleGamesFromQuery(query.rows, settings.limit);
		}
	});

	return games;
};

/**
 * returns the last 40 games played
 * @return {Game[]}
 */
Game.getRecent = function*(limit)
{
	// note the `g.id desc` - makes it easy for `parseMultipleGamesFromQuery` to iterate
	return yield Game.getMany({ limit: limit || 40,  orderBy: 'g.played_date desc, g.id desc' }); 
};


/* -------------------------------------------------------------------
 * Prototype Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */


/**
 * attempts to persist this Game to the database
 */
Game.prototype.save = function*()
{
	if (this.id) throw new Error('updating not supported currently');
	
	var validationError = validateBeforeSave(this);
	if (validationError)
	{
		throw new Error(validationError);
	}

	this.game_type_id = this.team1.length;

	// team1 always wins
	if (this.team1Score < this.team2Score)
	{
		var swap = this.team2Score;
		this.team2Score = this.team1Score;
		this.team1Score = swap;

		swap = this.team2;
		this.team2 = this.team1;
		this.team1 = swap;
	}

	yield insertGame(this);
};


/* -------------------------------------------------------------------
 * Private Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * Returns an array of games based on a query using {@link getSqlAndParams}
 * @param rows assumes these rows have contiguous game ids
 * @param limit optional max number of Games to parse
 * @return {Game[]}
 */
function parseMultipleGamesFromQuery (rows, limit)
{
	var games = [],
		currentGameId = rows[0].game_id,
		currentRows = [];
	
	// again, these had better have all of a game's rows together
	for (var i = 0; i < rows.length; i++)
	{
		var row = rows[i];
		
		if (row.game_id !== currentGameId)
		{
			games.push(parseGameFromQuery(currentRows));
			currentRows.length = 0;
			currentGameId = row.game_id;
			
			if (limit && games.length >= limit)
			{
				break;
			}
		}
		
		currentRows.push(row);
	}
	
	// and the last one, if we didn't exit early
	if (currentRows.length)
	{
		games.push(parseGameFromQuery(currentRows));
	}
	
	return games;
}

/**
 * Returns a {@link Game} from the sql resulting from {@link getSqlAndParams}
 * @param rows a single game's rows
 * @return {Game}
 */
function parseGameFromQuery (rows)
{
	var g = new Game();
	for (var i = 0; i < rows.length; i++)
	{
		var r = rows[i];
		if (i == 0)
		{
			g.id = r.game_id;
			g.played_date = r.played_date;
			g.game_type_id = rows.length / 2;
			g.match_id = r.match_id;
			g.recorded_by_player_id = r.recorded_by_player_id;
		}
		var p = new Player(r);

		// let's make the winner always be team 1
		if (r.is_winner)
		{
			g.team1.push(p);
			g.team1Score = r.score;
		}
		else
		{
			g.team2.push(p);
			g.team2Score = r.score;
		}
	}
	return g;
}

function* insertGame(game)
{
	yield Sql.using(function*(db)
	{
		// first insert the games row, then the games_players
		var dbResult = yield db.query(
			"insert into games (played_date, game_type_id, recorded_by_player_id) values ($1, $2, $3) returning id;",
			[game.played_date, game.game_type_id, game.recorded_by_player_id]);

		game.id = dbResult.rows[0].id;

		if (game.isSaved)
		{
			yield insertGamesPlayers(db, game, 1);
			yield insertGamesPlayers(db, game, 2);
		}
	});
}

function* insertGamesPlayers(db, game, teamNumber)
{
	var teams = game['team' + teamNumber],
		teamScore = game['team' + teamNumber + 'Score'],
		isWinner = teamNumber == 1;
	
	for (var i = 0; i < teams.length; i++)
	{
		yield db.query(
			'insert into games_players (game_id, player_id, is_winner, score) ' +
			'values ($1, $2, $3, $4);', [game.id, teams[i].id, isWinner, teamScore]);
	}
}

function getSqlAndParams(options)
{
	var defaults = 
	{
		gameId: null,
		matchId: null,
		playerId: null,
		limit: null,
		orderBy: null
	};
	var settings = PongUtils.extend({}, defaults, options);
	
	var sql = Sql.fromComment(function ()
	{/*!
	
select 
	g.id as game_id,
	g.played_date,
	g.recorded_by_player_id,
	g.match_id,
	p.id as player_id,
	p.name as player_name,
	p.email as player_email,
	p.image_url as player_image_url,
	p.rating,
	gp.is_winner,
	gp.score
from 
	games g 
	inner join games_players gp on g.id = gp.game_id 
	inner join players p on p.id = gp.player_id 
--[SqlBuilder: where]
--[SqlBuilder: order by]
--[SqlBuilder: limit]

*/
	});
	
	var builder = new SqlBuilder();
	var template = builder.newTemplate(sql);
	
	if (settings.limit && !settings.orderBy) throw new Error('when limiting, an orderBy must be specified');
	
	if (settings.matchId)
		builder.where('g.match_id = @matchId', settings);
	
	if (settings.gameId)
		builder.where('g.id = @gameId', settings);
	
	if (settings.limit)
		builder.limit(settings.limit * 4);
	
	if (settings.orderBy)
		builder.orderBy(settings.orderBy);

	return { sql: template.sql, params: template.params };
}

function validateBeforeSave(game)
{
	if (game.isSaved) 
		return 'already saved (update not supported)';
	
	if (!Array.isArray(game.team1) || !Array.isArray(game.team2))
		return 'teams should be arrays of players';
	
	if (game.team1.length !== game.team2.length)
		return 'teams should have the same number of players';
	
	if (game.team1.length !== Game.types.singles && game.team1.length !== Game.types.doubles)
		return 'only singles and doubles games are supported';
	
	if (game.team1Score < 0 || game.team2Score < 0)
		return 'scores must be positive';
	
	if (game.team1Score === game.team2Score)
		return 'scores cannot be equal';
	
	if (!game.recorded_by_player_id)
		return 'recorded_by_player_id is required';
	
	// TOOD: should we validate that one team won by at least two points?
	
	var team1Ids = game.team1.map(function(p) { return p.id; });
	if (game.team2.some(function(p) { return team1Ids.indexOf(p.id) >= 0; }))
		return 'players cannot be on both teams';
	
	return null;
}